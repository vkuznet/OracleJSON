ORACLE DB

1.  cursor.arraysize = 100
	This read-write attribute specifies the number of rows to fetch at a time internally 
    and is the default number of rows to fetch with the fetchmany() call. 
    It defaults to 50 meaning to fetch 50 rows at a time. Note that this attribute can drastically affect 
    the performance of a query since it directly affects the number of network round trips that need to be
    performed. This is the reason for setting it to 50 instead of the 1 that the DB API recommends

    In general, larger array sizes improve performance.
    There is a time/space tradeoff for increasing the arraysize. 
    Larger arraysizes will require more memory in Python for buffering the records.
	
2.  Using Bind Variables
	Bind variables enable you to re-execute statements with new values, without the overhead of reparsing the statement. Bind variables improve code reusability, and 	can reduce the risk of SQL Injection attacks.

3. Creating Transactions
	
	When you manipulate data in an Oracle Database (insert, update, or delete data), the changed or new data is only available within your database session until it is 	committed to the database. 
	When the changed data is committed to the database, it is then available to other users and sessions. This is a database transaction.

4. Fetch

	cx_Oracle.Cursor.fetchall() - Fetches all remaining rows of the result set as a list of tuples. If no more rows are available, it returns an empty list. Fetch 								  actions can be fine-tuned by setting the arraysize attribute of the cursor which sets the number of rows to return from the database 
								  in each underlying request. The higher setting of arraysize, the fewer number of network round trips required. The default value for 								  arraysize is 1.
	
	cx_Oracle.Cursor.fetchmany([rows_no]) -
	
	cx_Oracle.Cursor.fetchone() - 
	
5. 	cursor.arraysize = 100
	
	The arraysize is set to 100. This causes batches of 100 records at a time to be returned from the database to a cache in Python. This reduces the number of 	"roundtrips" made to the database, often reducing network load and reducing the number of context switches on the database server. The fetchone(), fetchmany() and 	even fetchall() methods will read from the cache before requesting more data from the database.
	
6. 	For JSON data processed by Oracle Database, any needed character-set conversions are performed automatically.

7. What about the performance of queries using the JSON_VALUE function? Because it’s essentially a full-text search, won’t it tax the database?

Oracle Database 12c knows there is JSON data in the column, and it can access the data with the JSON_VALUE function, so indexes can be created on those most used keys—just as with normal columns in database tables. Mark demonstrates this by creating a unique index on TransID inside the JSON document:

create unique index in_trans_trans_id
on transactions
(json_value(trans_msg,'$.TransId'));

Bitmap indexes are particularly useful in high-volume environments where the frequency of the values is low. For instance, the Acme Bank Flag key has just two possible values—true and false—to show whether a check is from Acme or not. It’s perfect for a bitmap index. Mark creates the index:

create bitmap index in_trans_acmeflag
on transactions
(json_value(trans_msg,
'$.CheckDetails.AcmeBankFlag'));

8. Sometimes users perform pattern-matching searches—for example, looking to see if an ATM in Stamford was used in any transaction. In such a case, they look for the word Stamford in the ATMLocation subkey within the ATMDetails key; they cannot perform an exact match. Here is what the query looks like:
select
  json_value(trans_msg,
             '$.TransId') trans_id,
  json_value(trans_msg,
             '$.Source') Source
where json_textcontains (
  trans_msg,
  '$.ATMDetails.ATMLocation',
  'Stamford'
);

Since this query is a free-format search, it will adversely affect the database performance. A special text index on the JSON data is created, using the following SQL:

create index ind_trans_01 
on transactions (trans_msg)
indextype is 
ctxsys.contextparameters ('section group 
CTXSYS.JSON_SECTION_GROUP 
sync (on commit)');

The parameter section contains a special clause that instructs Oracle Database to index the columns as JSON sections, which facilitates free-format searches.